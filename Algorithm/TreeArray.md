# 树状数组

## 从中值滤波说起

在 N 的范围(值域)内作中值滤波, 滤波参数为 r
排序时间复杂度假设为 2r+1 , 数据平移需要的复杂度为 N-(2r+1)+1
即总时间复杂度在
    (2r+1)[N-(2r+1)+1]
    
## 树状数组

### 节点意义

定义:
- A[] 为普通数组, C[] 为树状数组, C[i] 为树状数组上的节点
- 如果对于数组下标 x y (x < y), 如果 x+2^k=y (k 为 x 的二进制中末尾 0 的个数), 那么定义 [y, x] 为一组树上的父子节点, 其中 y 为父节点, x 为子节点
- [C[i] 的值 为它的所有子节点的值和 A[i] 的总和] or [C[i] 为原数组 A 的连续区间和]

例:
```
C1 = A1
C2 = C1 + A2 = A1 + A2
C3 = A3
C4 = C2 + C3 + A4 = A1 + A2 + A3 + A4
C5 = A5
C6 = C5 + A6 = A5 + A6
C7 = A7
C8 = C4 + C6 + C7 + A8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8
```

观察得出:
1. 当i 为奇数, C[i] 一定为叶子节点, 即 C[i] = A[i]{ i%2=1 }
2. C[i] 的最右元素一定是 A[i]
3. C[i] 的最左元素同时也是 最左子节点 的最左元素
4. C[i] 能够表示的 A 数组的区间的元素个数为 2^k

即 C[i] = sum { A[j] | i-2^k+1 <= j <= i } (提示: j 的两端点相减再 +1 = 2^k)

### 求和操作

前提:
1. C[i] = sum{ A[j] | i-2^k+1<=j<=i } 已知
2. 设 lowbit(i) 表示 2^k

求:
sum{ A[j] | 1<=j<=i }

分析:
```
sum(i) = sum { A[j] | 1<=j<=i } ............................ 1
       = A[1]+A[2]+..+A[i] ................................. 2
       = A[1]+A[2]+A[i-2^k]+A[i-2^k+1]+..+A[i] ............. 3
       = A[1]+A[2]+A[i-2^k]+C[i] ........................... 4
       = sum(i-2^k)+C[i] ................................... 5
       = sum(i-lowbit(i))+C[i] ............................. 6

```

**疑惑**:

*2->3 是为什么 ?? 不懂*


具体操作:


### 更新操作

前提:
与求和相同

求:
对 A[i] 的操作会影响到 哪些 C[i]

分析:
1. 每次更新 A[i] 是都需要更新 父节点 
2. 父节点递推为 x+2^k === x+lowbit(i)

具体操作:


### lowbit 函数的 O(1) 实现

```c
int lowbit(int x) {
  return x & -x;
}
```

#### 前置: 与运算

- 假设 x 末尾最多包含 (k) 个 0
- 则 -x 末尾也最多包含 (k) 个 0
- 把 x 与 -x 都转换为各自的补码, 再做与运算

结论: x & -x ==> 2^k

### 特性: 单点更新, 成端求和

- 空间复杂度 -- O(n)

- 时间复杂度
  - 查询/更新 -- O(n)
  - 求和 -- O(1)

# C++

## Lambda

形如

```cpp
[capture list] (params list) mutable exception-> return type { function body }
```

- capture list: 捕获外部变量列表
- params list: 形参列表
- mutable 指示符: 用来说用是否可以修改捕获的变量
- exception: 异常设定
- return type: 返回类型
- function body: 函数体

| 捕捉方式       | 说明                                                                                          |
| :-             | :-                                                                                            |
| `[]`           | 	不捕获任何外部变量                                                                        |
| `[变量名, …]` | 默认以值得形式捕获指定的多个外部变量(用逗号分隔), 如果引用捕获, 需要显示声明(使用&说明符) |
| `[this]`       | 	以值的形式捕获 this 指针                                                                  |
| `[=]`          | 	以值的形式捕获所有外部变量                                                                |
| `[&]`          | 以引用形式捕获所有外部变量                                                                    |
| `[=, &x]`      | 	变量 x 以引用形式捕获, 其余变量以传值形式捕获                                            |
| `[&, x]`       | 	变量 x 以值的形式捕获, 其余变量以引用形式捕获                                            |

Lambda 表达式的参数限制:
- 参数列表中不能有默认参数(可惜了)
- 不支持可变参数
- 所有参数必须有参数名

## 左值/右值

[C++ 左值与右值 ?](https://www.zhihu.com/question/26203703)

提示:
- 可被 & 取址的是左值, 不能被取址的是右值
- 左值和右值表达式都可以是 const 或 non-const

## 多态

1. 继承链中带虚函数的每一个类都有虚表
2. 虚表可以继承, 如果子类没有重写虚函数, 那么子类虚表中仍然会有该函数的地址, 只不过这个地址指向的是基类的虚函数实现
3. 如果基类有 n 个虚函数, 那么基类的虚表中就有 n 项(虚函数地址), 派生类也会有至少 n 项的虚表, 如果重写了相应的虚函数, 那么虚表中的地址就会改变, 指向自身的虚函数实现, 如果派生类有自己的虚函数, 那么该类及由该类派生的虚表中也会有相应的记录
3. 派生类的虚表中虚地址的排列顺序和基类的虚表中虚函数地址排列顺序相同
4. 采用晚绑定(运行时绑定), 在运行时, 依据对象的类型来确认调用的是哪一个虚函数实现, 体现 c++ 的多态性
5. 早期绑定, 编译时绑定

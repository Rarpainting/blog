# Java 中锁(概念)的分类

## 线程安全

使用共享内存上的线程安全

- 可见性

- 有序性

- 原子性 -- 由锁来解决

## 公平锁/非公平锁

### 公平锁

- 入队排他抢占锁

- ReentrantLock 可以设置为 FreeLock

### 非公平锁

- 先尝试性获取锁, 成功则插队执行后续, 失败则入队, 以排他形式抢占锁

- ReentrantLock 和 synchronized 默认 NoFreeLock

## 可重入锁

使用计数器保存已拥有的锁, 实现**多次**进入同步代码

## 独享锁/共享锁

## 互斥锁/都写锁

## 乐观锁/悲观锁

- **悲观锁如果使用不当(锁的条数过多), 会引起服务大面积等待. 推荐优先使用乐观锁 + 重试**
- mysql 的 innodb 存储引擎事务锁虽然是行锁, 但内部是锁**索引**的
- 锁相同数据的不同**索引条件**, 可能会引起死锁(例如两个事务锁的顺序相反)

### 乐观锁

volatile 变量 -- 关闭编译器的**顺序**优化, 要求

每次该变量修改后把变量写入变量地址
每次读取都从变量地址重新读一遍

#### CAS - ABA 问题

CAS - Compare and Swap

假设 线程 One 从目标内存 V 中读出**A**, 这时另一个线程 Tow 也读出**A**, 并且 Tow 进行操作后由**A**变成**B**, 然后又把 V 的**B**改回**A**
然后线程 One 进行 **CAS**, 发现内存中仍然时**A**, 于是认为本次 CAS 成功

### 悲观锁

- select for update : **行锁(X 锁)**(不可读, 不可写)

## 分段锁

## 偏向锁/轻量级锁/重量级锁

## 自旋锁

## 写时复制 -- Copy-On-Write

并发访问下, 当修改某 Container 的元素时, 不直接修改容器, 而是先复制一份副本, 在副本中修改
修改结束后, 将指向原来容器的引用指向副本容器

- 读/写操作分离, 适合**多读少写**的情况
- 内存开销大
- 最终一致性

## 死锁

条件:
- 互斥
- 持有
- 不可剥夺
- 环形等待

# Web 性能

## TCP

### TCP 调优

1. 增大 TCP 的初始拥塞窗口

  - 应对突发性的短暂连接

2. 慢启动重启

  - 在连接空闲是 **禁用慢启动** 可以改善瞬间发送数据的长 TCP 连接的性能

3. 窗口缩放(RFC 1323)

  - 增大最大接受窗口大小, 让 **高延迟** 的连接达到更好的吞吐量

4. TCP 快速打开(TFO -- TCP Fast Open)

  - 允许在第一个 SYN 分组中发送应用程序数据
  - 需要客户端和服务端共同支持
  
## HTTPS

### HTTPS 调优

- 把 TLS 库升级到最新版本, 在此基础上构建服务器
- 启动并配置 **会话缓存** 和 **无状态恢复**
- **监控** 会话缓存的使用情况并作出相应调整
- 在接近用户的地方完成 TLS 会话, 尽量减少往返延迟
- 配置 TLS 记录大小, 使其恰好能封装在一个 TCP 段内
- 确保 证书链 不会超过 拥塞窗口的对象
- 从 信任链 中去掉不必要的证书, 减少联调层次
- **禁用** 服务器的 TLS 压缩功能
- 启用服务器对 SNI(服务器名称指示) 的支持
- 启用服务器的 OCSP(在线证书状态协议 -- 实时检查证书状态的机制) 封装功能
- 追加 HTTP 严格参数安全首部(HSTS)
- **myssl**

## HTTP

示例: 谷歌搜索对 TTFB 的优化

在接到搜索后, 服务器立即向浏览器发送搜索页面的静态头部(或页眉)
然后在客户端解析头部的同时, 服务器开始搜索索引, 完成后, 再发送包含搜索结果的文档到客户端, 通过 JS 将动态信息写进 DOM 点

### HTTP 调优

#### 常规优化
- 减少 DNS 查询
- 减少 HTTP 请求
- 使用 CDN
- 添加 Expires 首部, 配置 ETag 标签
- Gzip 压缩资源
- 避免 HTTP 重定向

#### 进一步
- 使用 HTTP 持久连接(keep-alive)
- HTTP 管道 -- 把 FIFO 队列从客户端(请求队列)迁移到服务端(响应队列)
- 多个 TCP 连接 -- 服务器并行处理请求
- 域名分区
  - 浏览器连接限制针对主机名(域名), 而非 IP 名
  - 优先考虑多 TCP 连接
- 控制协议开销 -- 把多次连接压缩成一次, 减少协议字节对通讯的压力
- 连接和拼合
  - 把多个 JS 和 CSS 文件合并成 1 份文件
  - 把多张图片组合成一个更大的复合的图片, 通过 CSS 截取需要的部分
  - 降低初始启动速度换来预加载效果 -- 拆分稳定的核心部分(共用框架/库)
  - CSS 和 JS 合适的大小 -- 30 - 50 KB
- 嵌入资源(data:[mediatype][lbase64],data) -- 仅出现一次的小资源, 不需要多次载入
- 减少 HTTP Cookie 大小

*DNS 查询和 TCP 慢启动 导致额外消耗对高延迟客户端影响最大, 即 移动网络(3G 4G) 受过度分区影响最大*

### HTTP 2.0

概念:
- 所有通信在一个 TCP 连接上完成
- 流是连接中的一个承载(双向)消息的虚拟通道; 每个流有唯一一个整数标识符(1, 2, ... N)
- 消息是 请求 或 响应; 由一个或多个帧组成
- 帧是最小通信单位

#### 多向请求和响应

允许发送方乱序的发送请求帧, 接收方获得使用帧后重排序整个请求

#### 请求优先级

为每个流带有 31 bit 的优先值

#### 每个来源仅一个连接

同双向的数据流共用 **一个** 连接

#### 流量控制

HTTP2.0 流量控制机制
1. 流量控制基于每一跳进行, 而非端到端的控制
2. 流量控制基于窗口更新帧进行: 接收方广播自己准备接收 *某个数据流* 的多少字节 , 以及对 *整个连接* 也接收多少字节
3. 流量控制窗口大小通过 **WINDOW_UPDATE 帧** 更新, 这个字段指定了 **流 ID 和 窗口大小递增值**
4. 流量控制有方向性: 即接收方可能 *根据情况* 为每个流乃至整个连接, 设置任意窗口大小
5. 流量控制可以由接收方禁用, 包括针对 个别的流 和针对 整个连接

#### 服务器推送

- *客户端* 可以缓存推送过来的数据
- *客户端* 可以拒绝推送过来的数据
- 推送资源可用于 *不同的页面* 共享
- 服务器可以按照 *优先级* 推送资源
- 所有推送的资源都遵守 **同源策略**
- 推送的资源会直接进入客户端缓存, 不存在(API / JS 等的) **通知机制**

PUSH_PROMISE

- 该帧中只包含要约(promise)资源的 HTTP 首部
- 客户端接收到 PUSH_PROMISE 后, 可以选择性的拒绝该流
- PUSH_PROMISE 帧只能借由对请求的响应推送资源; 同时 PUSH_PROMISE 帧必须在返回响应(Response)前发送, 以免客户端出现竞态(例如客户端请求的资源恰好是服务器计划推送的资源)

#### 首部压缩

- HTTP2.0 在客户端和服务端使用 "首部表"来跟踪和存储之前发送的键值对, 对于相同的数据, 不在通过每次请求和响应发送
- 首部表在 HTTP2.0 的连接存续期内始终存在, 由客户端和服务端共同渐进的更新
- 每个新的首部键值对要么被追加到当前表的末尾, 要么

#### HTTP2 发现和升级

现代浏览器仍然需要同时兼容 HTTP 1.x 和 HTTP 2.0, 而此时往往有三种情况

- 通过 TLS 和 ALPN 发起新的 HTTPS 连接
- 根据之前的信息发起新的 HTTP 连接
- 没有之前的信息发起新的 HTTP 连接

在常规非加密信道建立 HTTP 2.0 连接需要 HTTP upgrade 机制支持

```Req
GET /page HTTP/1.1
Host: server.example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: HTTP/2.0
HTTP2-Settings: (SETTINGS payload) -- HTTP/2.0 SETTINGS 净荷的 Base64 URL 编码
```

```Resp
HTTP/1.1 200 OK
Content-length: 243
Content-type: text/html

(HTTP 1.1 response)
```

```Resp
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: HTTP/2.0

(HTTP 2.0 response)
```

#### 二进制分帧


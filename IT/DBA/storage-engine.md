# 存储引擎

## B-Tree

为磁盘和内存而优化

1. 对 B 树的写入过程是一次 **原位写入** 的过程
2. 主要分为两个部分, 首先是查找到对应的块的位置, 然后将新数据写入到刚才查找到的数据块中, 然后再查找到块所对应的磁盘物理位置, 将数据写入去
3. 在内存比较充足的时候, 因为 B 树的一部分可以被缓存在内存中, 所以查找块的过程有一定概率可以在内存内完成, 不过为了表述清晰, 我们就假定内存很小, 只够存一个 B 树块大小的数据吧
4. 可以看到, 在上面的模式中, 需要两次随机寻道(一次查找, 一次原位写), 才能够完成一次数据的写入, 代价很高

## LSM 树(Log-Structured Merge Tree)

代表数据库: nessDB, levelDB, HBase

核心思想: 通过 **批量存储** 技术规避磁盘随机写入问题, 放弃部分读能力

> 假定内存足够大, 不需要每次有数据就必须将数据写入到磁盘中, 可以将 *最新* 的数据驻留在内存中;
> 在积累到足够多后, 通过 归并排序 将内存内的数据合并到磁盘队尾

如果要最大化发挥磁盘的技术特性, 一次性的读取或写入固定大小的一块数据, 并尽可能的减少随机寻道操作的次数

特性:
- **批量写入, 存储延迟**
- 相比于 B-tree , 能显著地减少磁盘磁盘臂的开销, 并能在较长的时间内提供对文件的高速插入
- 在需要查询高速响应的时候性能不佳

适用于: 索引插入比检索更频繁的场景

![LSM-Tree](20141110091559148.jpg)

LSM-Tree 优化方案

### Bloom filter

带随机概率的 Bitmap

### Compact 

## LSH 树()

## FractalTree

## Hash Map

特性:
- 支持 O(1) 的增删读写操作, 支持随机读写
- 不支持顺序读写, 不支持范围读写

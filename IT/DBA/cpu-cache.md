# CPU 缓存和伪共享

CPU 的缓存是按缓存行组成的, 典型的是 64 字节

## CPU 缓存共享

1. 请求核直接访问目标核, 但是每次的跨核访问都会经过有限带宽的 **Memory Controller**
2. 缓存行的传输, 需要能获取目标行是否被修改

## MESI 协议

- M(修改, Modified): 本地处理器已经修改缓存行, 即行已脏; 此 cache 内容已经与内存中的不一样, 并且此 cache, 只有本地一个拷贝(专有)
- E(专有, Exclusive): 缓存行内容和内存中的一样, 并且其他处理器**都没有**这行数据
- S(共享, Shared): 缓存行内容和内存中的一样, 有可能其他处理器**也存在**此缓存的拷贝
- I(无效, Invalid): 缓存行失效, 不能使用

缓存行的四种状态转换规则:
- 初始: 缓存行没有加载任何数据, 即 I(无效)
- 本地读写
  - 本地写(Local Write): 如果本地处理器写数据至处于 I(无效) 状态的缓存行, 则缓存行的状态变成 M(修改)
  - 本地读(Local Read):
    - 其他处理器的缓存中*也没有*这行数据, 则从内存(内存可能再向磁盘请求)中加载该行数据, 并设为 E(专有)
    - 其他处理器中有此缓存行的状态, 则读进本地缓存, (无论之前缓存行状态是 S 或者 E)并设置该行数据为 S(共享)
- 远程读写
  - 远程读(Remote Read): 目标核通过**内存控制器(Memory Controller)**将请求核的目标数据发送过去, 将该数据设为 S(共享), 同时内存也缓存了该行数据
  - 远程写(Remote Write): 假设请求核知道(?)其他核也有目标数据的备份, 为了修改该数据, 请求核发出一个 **RFO(Request For Owner)请求**, (以需要拥有这行数据的权限), 其他核的相应缓存将设为 I(无效) -- 保障了数据安全, 同时处理 PFO 请求/设置 I(无效)带来了巨大的性能消耗
